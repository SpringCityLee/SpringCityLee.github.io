**处理过线上OOM问题没有，如何处理的？**
*

**产线服务器CPU飙高如何处理？**

*   定位进程：使用TOP命令，确认使用CPU高的进程
*   定位线程：TOP-HP 定位线程是哪个线程CPU使用率高
*   以实际项目为例，定位到是一个加密服务CPU使用率高，查看代码。发现代码中的validator每次调用都重新初始化，而加解密服务调用的频次很高，所以产生了CPU飙升的问题。另外还发现日志没有异步写也导致CPU飙升。

**产线其他问题有没有遇到，如何处理？**

*   一个超时问题，产线没有代码变更，外部商户通知我们处理中的订单数最近比例越来越高。拿到单号后，分析到时外部商户调用接口A，A调用B时，B返回A超时，导致外部商户没有收到结果。通过具体订单发现订单时间很集中，在凌晨2：00-2：15很多，根据单号查询对应日志，发现接受到订单到返回花了几分钟的时间，且所有问题订单的表现都一样。查看具体代码，发现代码中接收到请求的AOP日志有输出，但是紧接着service的日志输出已经在几分钟之后。怀疑时AOP代码存在问题，排查AOP代码，未发现任何问题，但是还是把该方法的AOP日志打印去掉，重新上线。第二天发现问题还是没有解决。于是考虑该请求线程没有问题，或许被其他线程影响。叫运维直接导出进三天全部日志。查看发生问题时间的日志发现，存在一个超长的日志打印，该日志时异步打印，但是依然导致了服务无法处理其他请求。日志删掉后服务正常。后续将产生该日志的查询请求优化，不再提供该大量订单的查询接口。且项目中慎用AOP环绕打印service日志。

**对线程池的理解，项目中哪个地方用到了线程池，如何使用的，用的Excutor中的哪个实现类，为什么？**

*   使用线程池的好处：线程重复利用，节省线程创建及消耗的资源消耗；管理线程，避免滥用线程带来的资源消耗、内存溢出等问题
*   线程池的处理流程：检查核心线程池--队列是否已满--线程池是否已满--线程池拒绝策略（默认丢弃任务并抛出异常）
*   不用任何excutor实现类，fixed不灵活，cache不能限制，singal单线程，可以参照cachedTreadPool的实现方式，将最大线程数由INTEGER.MAX_VALUE修改为服务需要的具体数字

**CAS,以及CAS带来的问题如何解决**

* compare and swap，对比数据是否正确，然后再修改。可能存在ABA问题，可以对记录增加版本号标记，对比数据是否正确的时候也对比版本号是否正确

**Volatile底层，synchronized底层、锁升级过程、MESI**

*   利用lock前缀实现内存可见性，内存屏障实现禁止指令重排序
*   synchronized用对象头中锁状态以及monitor指令实现，修饰代码块时，编译后可以看见monitorentor及monitorexit指令。修饰方法时方法会被ACC_SYNCHRONIZED标记为同步方法
*   锁升级过程：当一个线程进入同步代码块时，默认为偏向锁，出现竞争会膨胀为轻量级锁，在轻量级锁的标识下如果还有竞争会膨胀为重量级锁。偏向锁，偏向锁无需CAS即可获取锁（偏向锁标志及线程ID），轻量级锁通过自旋获取锁，自旋次数过多会膨胀为重量级锁
*   MESI：  Modify，当CPU缓存中数据被修改时，即与主存不一致，该缓存行标记为modify。Exclusive，当modify缓存行被写入缓存中时，未被其他CPU读取时标标记为独享状态。Shared，当该缓存行被多个CPU缓存，且数据与主存一致，标记为共享。Invalid，当该缓存行被任意CPU修改，其他CPU中的缓存行被标记为无效（修改数据的缓存行标记为modify）。

**对mysql索引的理解，对组合索引的理解，索引的最佳实践**

*   索引是一种便于搜索的数据结构。mysql使用b+tree作为索引结构，innodb叶子节点存数据，myisam叶子节点存数据地址。innodb为聚簇索引，myisam为非聚簇索引。B+Tree的特征，每行存索引ID及子节点的指针，非叶子节点不存数据，主键索引叶子节点存记录数据，辅助索引叶子节点存主键，每个叶子节点之间存在指针。组合索引可以让直接在索引中找到索引值，组合索引的使用要遵从最左前缀原则    
*   索引的最佳实践：创建索引时，对where及order中的字段创建索引，使用时要避免索引失效（is null，like%等）。  

**分布式锁的实现，对比redis与zk的分布式锁**

*   项目中使用的redis作为分布式锁，使用set多参方法加锁，将值与过期时间同时作为入参。ZK分布式锁由锁了解，利用临时节点实现，解锁后删除临时节点。
*   对比ZK与redis，性能redis由于ZK，稳定性zk优于redis，如果redis上锁的客户端宕机，则只能等待超时时间后解锁，但是zk由于时临时节点，宕机则解锁  

**唯一ID如何实现，雪花算法的原理及存在的问题，如何避免根据单号推算出今天的单量**

*   数据库分段+本地缓存：每次服务启动，缓存1000个ID，数据库对应加1000，每个服务缓存不同段的ID，在代码中加上时间戳实现趋势递增。这种算法无法推算出当天的单量
*   雪花算法：自增ID+机器ID+时间戳，存在问题：服务器时针回拨可能导致单号重复。    

**如果线上一个功能是用栈结构实现的，使用过程中需要注意哪些问题，为什么**

*   栈结构为先进后出结构，则需要考虑最先入栈的任务可能永远也不会执行到，所以栈的深度不能太深    

**怎么理解线程安全**    

*   对竞争数据保证只有一个线程可以访问，避免脏读。

**怎么理解接口幂等，项目中如何保证接口幂等**

*   根据业务ID加分布式锁；乐观锁，在数据存储的时候去判断数据是否已经被处理；
    **怎么理解微服务，服务如何划分，微服务带来的好处与坏处**
*   微服务相对于单体服务来说，功能解耦，部署方便，协作更容易。微服务的划分一般以业务功能划分，不同的业务部署为不同的服务，当然也可以从技术层面划分，比如技术中间件。微服务带来的好处上面已经说了，坏处：服务增多，系统复杂度怎加，运维成本增加，分布式事务等也需考虑    

**如何理解网关，网关带来的好处和坏处，如何解决**

*   网关的作用：数据安全验证，限流熔断

**hystrix**

*   没用过

**怎么理解命令模式和观察者模式，手写命令模式/观察者模式/策略模式**
        
**掌握哪些设计模式，常用哪些，项目中如何使用，手写线程安全的单例**

*   单例：饿汉模式/双重检查单例/内部类

**设计秒杀系统**

*   从高性能、高可用和数据安全三个方面入手
*   高性能：配置静态活动页面，使用redis扣减库存
*   高可用：限流+降级，部署redis集群，服务端水平扩容等
*   数据安全：利用redis单线程来扣减实时库存，异步扣减数据库，保证最终一致性即可    

**如果现在要实现每秒10W请求，不能熔断限流，如何设计**

*   限流+集群扩容   

**假设现在双11零点，大量下单请求，如何对这些订单分库分表，为什么**

*   因为只是单量需要做分库分表，而不是数据库字段设计的问题，那么只需要考虑水平拆分即可，如果担心双11零点订单量过大导致新数据库实例无法承担的话，可以考虑订单号hash值做分库分表，这样保证请求散落均匀，不至于单台集器压力过大    

**服务A调用服务B，服务B调用服务C，如何保证B响应A成功，则服务C一定响应服务B成功，需要考虑系统性能问题** 

*   B服务只做参数校验及业务校验，直接返回。C异步处理，B必须保证C异步处理过程中所需要依赖的数据都验证证据。这样C就能保证一定成功，即使不成功，只用继续重试C即可

**递归使用中有什么需要注意的地方，递归一般可以用什么去替换**

*   递归过程中因为是反复执行同一段代码，所以要注意避免死循环，找到合适的临界点退出。递归算法一般可以用动态规划代替，动态方程即是递归过程中需要递归执行的代码    

**有两个表，table A，table B，写sql查询出仅在tableA的数据，仅在B的数据，既在A又在B的数据**

*   select * from A where id not in （select id from b）
*   select * from A left join B on A.id=B.id WHERE B.id=null
*   union/left join +B.id不为null

**Spring源码有没有了解**

*   以前看过，不记得了

**Mybatis源码有没有了解**

*   只记得执行sql的流程，创建sqlSessionFactory-->获取session-->获取mapper代理-->执行sql-->session提交事务或回滚事务-->session关闭连接


**mysql事务隔离级别、MVCC**

*   mysql默认不可重复读（读提交，read_commited）.
*   mvcc，解决在隔离级别为RR及RC时并发读-写的版本控制，每次修改记录时，在版本链中记录事务ID及上次提交的版本号。在redadview中可以查看活跃事务列表，在活跃事务列表之前的事务时可见的。

**两个数字类型的字符串，直接转int或dubbo都放不下，求这个两个数的和，返回还是字符串，15min完成**

*   由尾向前，逐位求和即可。

**寻找目标位置，有一个二维数组，数组横向有序，纵向有序，求目标值的位置，10min**

*   横向找到对应坐标，再纵向找到对应坐标



